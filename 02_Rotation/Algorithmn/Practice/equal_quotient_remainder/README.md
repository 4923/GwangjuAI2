# 나머지와 몫이 같은 수 구하기

## Remind
1. 효율을 생각해야 한다. 문제가 나온 의도가 나의 풀이 방식과 같은지 생각해 볼 것.  
2. 내가 떠올린 방법 **말고도** 다른 방법은 없을지 고민하는 습관을 들이자.  
3. 주어진 test case 외의 반례가 없을지 고민하자.

## Solution 1
### idea

- N = 1, (X)
- N = 2, (3)
- N = 3, (4, 8)
- N = 4, (5, 10, 15)

N이 0이어도 상관 없지만 모든 자연수라는 범위이므로 제외

조건에 들어맞는 수는 N+1의 N-1배수까지다.  
(if N == 5: 6, 12, 18, 24)

- (n+1) 을 (n-1)배수까지 더하면 (ex: 5를 3배수까지 더하면)

### code

```python
def get_same_qand_r(n):
    res = 0
    for i in range(1, n):
        res += i * (n+1)
```

- 내 풀이에서 range를 N-1, 0, -1 로 잡았는데 왜 그렇게 잡았었지...? 굳이 그럴 필요가 없었다.

## Solution 2
### idea
나머지의 개수는 나누는 수에 의존한다.
```python
def get_same_q_and_r_sum(n):
    res = 0
    for i in range(1, n):
        res += (i*n) + i    # 마지막의 i : 나머지를 따로 더한다.
```

Solution 1의 괄호를 푼 식이라 1이나 2나 다른것은 없다.

## Gauss Sum
위의 두 풀이는 N의 크기에 따라 속도가 달라진다. N의 범위가 크다면 그 범위를 좁힐 방법이 없는지 고민해보자.

- 가우스 덧셈 또는 가우스 합 
    - 1부터 n까지의 합 =  n(n+1)/2
    - 이 경우 n번만큼의 반복문을 돌릴 필요가 없어진다.

문제에서 **배수**라는 특징을 알려주었으므로 (n+1)*(n-1)*n/2 으로 반복문 없이 풀 수 있다.   

가우스 합 공식에서 n+1은 공차가 1인 등차수열 조건에서 시작값과 끝값을 더한 값이고 이를 숫자 갯수의 반(n/2)번 곱한값이 해당 수열의 총합이다.  
따라서 이를 문제에 적용하면
1. 최대값인 (n+1) * (n-1)에 최소값인 (n+1) * 1을 더하여 시작값과 끝값을 더한 (n+1) * n을 만들고
2. 이에 반복횟수의 반 (n-1)/2 번을 곱하면
3. 최종 공식이 나온다 : (n+1)*(n-1)*n/2 