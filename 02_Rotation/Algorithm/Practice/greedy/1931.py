# 문제
# 한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다.
# 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고,
# 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자.
# 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다.
# 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

# 입력
# 첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다.
# 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데
# 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다.
# 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.

# 출력
# 첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.

# 힌트
# (1,4), (5,7), (8,11), (12,14) 를 이용할 수 있다.


# 입력
import sys

N = int(input())
conference_info = [list(map(int, sys.stdin.readline().strip().split())) for _ in range(N)]

# 그리디 : 현재 상황에서 가장 좋아보이는것이 결과적으로도 좋은 선택인가?
# 현재 상황에서 가장 좋아보이는 것 :
# 1. 회의시간이 짧다 (끝 - 시작이 최소인 값)
# 2. 다음 회의까지의 시간이 가장 짧다.
# 보장할 수 있는 이유 : sort 했기 때문 (end+1에서 시작하는 첫 값의 회의시간이 가장 짧다.)

# conference_info.sort()  # 끝나는 시간을 기준으로 sort 하고 싶은데 => key=lambda 이용
conference_info.sort(key=lambda x: x[1])
print(conference_info)

cnt = 1
idx = -1
start, end = conference_info[0][0], conference_info[0][1]

while idx < N:
    idx += 1
    if end <= conference_info[idx][0]:
        cnt += 1

print(cnt)


# ---------------

# 회의 개수만 고려해야한다. 시간으로 쪼개면 21억을 계산해야 하기 때문
# 이 때 : 정렬을 이용하자

# ! 정렬할 때 주의사항
# 일반적으로 정렬하려고 하면 : 두개 이상의 값일 때 앞 값을 기준으로 정렬된다
# 물론 첫번째 값이 동일하면 그 다음순위로 다음값을 비교한다 (e.g. [(3, 4), (2, 5), (2, 3)] => [(2, 3) (2, 5), (3, 4)])

# 두번째 값으로 정렬하려면 : lambda를 쓰고 귀찮아진다.

# 일단 중요한건 끝나는 시간이다.

# 겹칠 수 있는 가능성 중에서 : 이게 뭔소리지?
